{"version":3,"sources":["../ts/Main.ts","../ts/Maze/Maze.ts","../ts/Maze/MazeGenerator.ts","../ts/Maze/MazeNode.ts","../ts/Maze/MazeNodeIndex.ts","../ts/Maze/MazeNodeRelation.ts","../ts/Maze/MazeNodeRelationSlot.ts","../ts/Rendering/MazeRenderer.ts"],"names":[],"mappings":";AAEA,cAAM,IAAI;IACR,OAAO,CAAC,YAAY,CAAS;IAC7B,OAAO,CAAC,IAAI,CAAyB;IACrC,OAAO,CAAC,KAAK,CAAc;;IA8B3B,OAAO,CAAC,uBAAuB;CAOhC;AC1CD,cAAM,IAAI;IAER,OAAO,CAAC,MAAM,CAAe;IAC7B,OAAO,CAAC,SAAS,CAAS;IAC1B,OAAO,CAAC,SAAS,CAAS;gBAEd,UAAU,MAAM,EAAE,UAAU,MAAM;IAcvC,WAAW,IAAI,MAAM;IAIrB,WAAW,IAAI,MAAM;IAIrB,cAAc,CAAC,GAAG,MAAM,EAAE,GAAG,MAAM,GAAG,QAAQ,GAAG,IAAI;CAS7D;ACrCD,cAAM,aAAa;WACH,oBAAoB,IAAI,IAAI;WAK5B,iBAAiB,IAAI,IAAI;CAsDxC;AC1DD,cAAM,QAAQ;IAEV,OAAO,CAAC,YAAY,CAAuB;IAC3C,OAAO,CAAC,aAAa,CAAwB;IAC7C,OAAO,CAAC,WAAW,CAAwB;IAC3C,OAAO,CAAC,aAAa,CAAwB;IAC7C,OAAO,CAAC,cAAc,CAAwB;gBAElC,aAAc,YAAY,CAAC,MAAM;IAQtC,CAAC,IAAK,MAAM;IAIZ,CAAC,IAAK,MAAM;IAIZ,eAAe,CAAC,UAAW,gBAAgB,EAAE,OAAQ,aAAa,GAAI,IAAI;IAI1E,gBAAgB,CAAC,UAAW,gBAAgB,EAAE,OAAQ,aAAa,GAAI,IAAI;IAI3E,aAAa,CAAC,UAAW,gBAAgB,EAAE,OAAQ,aAAa,GAAI,IAAI;IAIxE,eAAe,CAAC,UAAW,gBAAgB,EAAE,OAAQ,aAAa,GAAI,IAAI;IAI1E,eAAe,IAAK,oBAAoB;IAIxC,gBAAgB,IAAK,oBAAoB;IAIzC,aAAa,IAAK,oBAAoB;IAItC,eAAe,IAAK,oBAAoB;CAGlD;ACzDD,aAAK,aAAa;IAEd,KAAK,IAAA;IACL,MAAM,IAAA;CACT;ACJD,cAAM,gBAAgB;IACpB,OAAO,CAAC,MAAM,CAAW;IACzB,OAAO,CAAC,MAAM,CAAW;IACzB,OAAO,CAAC,WAAW,CAAU;gBAEjB,OAAO,QAAQ,EAAE,OAAO,QAAQ,EAAE,YAAY,OAAO;IAM1D,OAAO,CAAC,WAAW,aAAa,GAAI,QAAQ;IAW5C,UAAU,IAAK,OAAO;CAG9B;ACzBD,cAAM,oBAAoB;IACxB,OAAO,CAAC,SAAS,CAA0B;IAC3C,OAAO,CAAC,UAAU,CAAuB;;IAOlC,UAAU,IAAI,OAAO;IAIrB,cAAc,IAAI,QAAQ,GAAG,IAAI;IAkBjC,GAAG,CAAC,UAAW,gBAAgB,EAAE,OAAQ,aAAa;CAI9D;ACnCD,cAAM,YAAY;WAEI,SAAS,CAAC,QAAS,YAAY,CAAC,SAAS,EAAE,UAAW,MAAM;WAyBpE,cAAc,CAAC,QAAS,YAAY,CAAC,SAAS,EAAE,QAAS,YAAY,CAAC,MAAM,EAAE,SAAU,YAAY,CAAC,OAAO;WAUpG,cAAc,CAChC,MAAM,IAAI,EACV,QAAQ,YAAY,CAAC,SAAS,EAC9B,YAAY,YAAY,CAAC,MAAM;CAiHlC","file":"hcpbrmaze.d.ts","sourcesContent":["/// <reference path=\"HWV/hoops_web_viewer.d.ts\" />\r\n\r\nclass Main {\r\n  private _containerId: string;\r\n  private _hwv: Communicator.WebViewer;\r\n  private _maze: Maze | null;\r\n\r\n  constructor() {\r\n    this._containerId = \"viewer\";\r\n\r\n    this._hwv = new Communicator.WebViewer({\r\n      containerId: this._containerId,\r\n    });\r\n\r\n    this._maze = null;\r\n\r\n    this._hwv.setCallbacks({\r\n      sceneReady: () => {\r\n          this._hwv.view.setBackgroundColor(Communicator.Color.blue(), Communicator.Color.white());\r\n          this._initResizeEventHandler();\r\n\r\n          this._maze = MazeGenerator.generateHardcoded();\r\n          MazeRenderer.createMazeMesh(this._maze, this._hwv, this._hwv.model.getAbsoluteRootNode());\r\n        },\r\n      selectionArray: (selectionEvents:Communicator.Event.NodeSelectionEvent[]) => {\r\n        const selectionIds = selectionEvents.map(sEvent => sEvent.getSelection().getNodeId());\r\n        for(let selectionId in selectionIds){\r\n          console.log(\">>>> \" + selectionId);\r\n        }\r\n      },\r\n    });\r\n\r\n    this._hwv.start();\r\n  }\r\n\r\n  private _initResizeEventHandler() {\r\n    window.addEventListener(\"resize\", () => {\r\n      this._hwv.resizeCanvas();\r\n    });\r\n\r\n    this._hwv.resizeCanvas();\r\n  }\r\n}\r\n","class Maze {\r\n  // Note : (0,0) is bottom left, first rows then columns\r\n  private _cells: MazeNode[][];\r\n  private _colCount: number;\r\n  private _rowCount: number;\r\n\r\n  constructor(rowCount: number, colCount: number) {\r\n    this._colCount = colCount;\r\n    this._rowCount = rowCount;\r\n    this._cells = new Array<Array<MazeNode>>();\r\n\r\n    for (let rowIndex = 0; rowIndex < rowCount; ++rowIndex) {\r\n      let row: MazeNode[] = new Array<MazeNode>();\r\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\r\n        row.push(new MazeNode(new Communicator.Point2(colIndex, rowIndex)));\r\n      }\r\n      this._cells.push(row);\r\n    }\r\n  }\r\n\r\n  public getRowCount(): number {\r\n    return this._rowCount;\r\n  }\r\n\r\n  public getColCount(): number {\r\n    return this._colCount;\r\n  }\r\n\r\n  public getNodeAtCoord(x: number, y: number): MazeNode | null {\r\n    let node: MazeNode | null = null;\r\n\r\n    if (x >= 0 && x < this._colCount && y >= 0 && y < this._rowCount) {\r\n      node = this._cells[y][x];\r\n    }\r\n\r\n    return node;\r\n  }\r\n}\r\n","class MazeGenerator {\r\n  public static generateProcedurally(): Maze {\r\n    // TODO : Zachary\r\n    return new Maze(0, 0);\r\n  }\r\n\r\n  public static generateHardcoded(): Maze {\r\n    let rowCount = 30;\r\n    let colCount = 50;\r\n    let maze = new Maze(rowCount, colCount);\r\n\r\n    // Each node will create its down / right relations and fill according left / up of related nodes.\r\n    for (let row = 0; row < rowCount; ++row) {\r\n      for (let col = 0; col < colCount; ++col) {\r\n        let currentNode: MazeNode | null = maze.getNodeAtCoord(col, row);\r\n\r\n        if (currentNode != null) {\r\n          let rightNode: MazeNode | null = maze.getNodeAtCoord(col + 1, row);\r\n          let downNode: MazeNode | null = maze.getNodeAtCoord(col, row + 1);\r\n\r\n          // Note about random wall draw\r\n          // 25% chances => [0,74] = free, [75,100] = wall\r\n\r\n          if (rightNode != null) {\r\n\r\n            let random: number = Math.floor(Math.random() * 100);\r\n            let hasWall: boolean = random >= 75;\r\n\r\n            let relation: MazeNodeRelation = new MazeNodeRelation(\r\n              currentNode,\r\n              rightNode,\r\n              !hasWall\r\n            );\r\n          \r\n            currentNode.setRightRelation(relation, MazeNodeIndex.First);\r\n            rightNode.setLeftRelation(relation, MazeNodeIndex.Second);\r\n        }\r\n\r\n        if(downNode != null){\r\n            let random: number = Math.floor(Math.random() * 100);\r\n            let hasWall: boolean = random >= 75;\r\n\r\n            let relation: MazeNodeRelation = new MazeNodeRelation(\r\n              currentNode,\r\n              downNode,\r\n              !hasWall\r\n            );\r\n          \r\n            currentNode.setDownRelation(relation, MazeNodeIndex.First);\r\n            downNode.setUpRelation(relation, MazeNodeIndex.Second);\r\n        }\r\n        }\r\n        else{\r\n            throw \"Current node is not supposed to be null\";\r\n        }\r\n      }\r\n    }\r\n\r\n    return maze;\r\n  }\r\n}\r\n","/// <reference path=\"../HWV/hoops_web_viewer.d.ts\" />\r\n\r\nclass MazeNode\r\n{\r\n    private _coordinates : Communicator.Point2;\r\n    private _leftRelation : MazeNodeRelationSlot;\r\n    private _upRelation : MazeNodeRelationSlot;\r\n    private _downRelation : MazeNodeRelationSlot;\r\n    private _rightRelation : MazeNodeRelationSlot;\r\n    \r\n    constructor(coordinates : Communicator.Point2){\r\n        this._coordinates = coordinates;\r\n        this._leftRelation = new MazeNodeRelationSlot();\r\n        this._upRelation = new MazeNodeRelationSlot();\r\n        this._downRelation = new MazeNodeRelationSlot();\r\n        this._rightRelation = new MazeNodeRelationSlot();\r\n   }\r\n\r\n    public x() : number{\r\n        return this._coordinates.x;\r\n    }\r\n\r\n    public y() : number{\r\n        return this._coordinates.y;\r\n    }\r\n\r\n    public setLeftRelation(relation : MazeNodeRelation, index : MazeNodeIndex) : void {\r\n        this._leftRelation.set(relation, index);\r\n    }\r\n\r\n    public setRightRelation(relation : MazeNodeRelation, index : MazeNodeIndex) : void{\r\n        this._rightRelation.set(relation, index);\r\n    }\r\n\r\n    public setUpRelation(relation : MazeNodeRelation, index : MazeNodeIndex) : void{\r\n        this._upRelation.set(relation, index);\r\n    }\r\n\r\n    public setDownRelation(relation : MazeNodeRelation, index : MazeNodeIndex) : void{\r\n        this._downRelation.set(relation, index);\r\n    }\r\n\r\n    public getLeftRelation() : MazeNodeRelationSlot{\r\n        return this._leftRelation;\r\n    }\r\n\r\n    public getRightRelation() : MazeNodeRelationSlot{\r\n        return this._rightRelation;\r\n    }\r\n    \r\n    public getUpRelation() : MazeNodeRelationSlot{\r\n        return this._upRelation;\r\n    }\r\n    \r\n    public getDownRelation() : MazeNodeRelationSlot{\r\n        return this._downRelation;\r\n    }\r\n}","enum MazeNodeIndex\r\n{\r\n    First,\r\n    Second\r\n}","class MazeNodeRelation {\r\n  private _node1: MazeNode;\r\n  private _node2: MazeNode;\r\n  private _pathIsFree: boolean;\r\n\r\n  constructor(node1: MazeNode, node2: MazeNode, pathIsFree: boolean) {\r\n    this._node1 = node1;\r\n    this._node2 = node2;\r\n    this._pathIsFree = pathIsFree;\r\n  }\r\n\r\n  public getNode(nodeIndex: MazeNodeIndex) : MazeNode\r\n  {\r\n    switch (nodeIndex) {\r\n      case MazeNodeIndex.First:\r\n        return this._node1;\r\n\r\n      case MazeNodeIndex.Second:\r\n        return this._node2;\r\n    }\r\n  }\r\n\r\n  public isPathFree() : boolean{\r\n      return this._pathIsFree;\r\n  }\r\n}\r\n","class MazeNodeRelationSlot {\r\n  private _relation: MazeNodeRelation | null;\r\n  private _nodeIndex: MazeNodeIndex | null;\r\n\r\n  constructor() {\r\n    this._relation = null;\r\n    this._nodeIndex = null;\r\n  }\r\n\r\n  public isPathFree(): boolean {\r\n    return this._relation != null ? this._relation.isPathFree() : false;\r\n  }\r\n\r\n  public getRelatedNode(): MazeNode | null {\r\n    let node = null;\r\n\r\n    if (this._relation != null && this._nodeIndex != null) {\r\n      switch (this._nodeIndex) {\r\n        case MazeNodeIndex.First:\r\n          node = this._relation.getNode(MazeNodeIndex.Second);\r\n          break;\r\n\r\n        case MazeNodeIndex.Second:\r\n          node = this._relation.getNode(MazeNodeIndex.First);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  public set(relation : MazeNodeRelation, index : MazeNodeIndex){\r\n      this._relation = relation;\r\n      this._nodeIndex = index;\r\n  }\r\n}\r\n","class MazeRenderer {\r\n\r\n  public static async loadImage(viewer : Communicator.WebViewer, filename : string) {\r\n    const p : Promise<XMLHttpRequest> = new Promise((resolve, reject) => {\r\n        const request = new XMLHttpRequest();\r\n        request.open(`GET`, filename, true);\r\n        request.responseType = `arraybuffer`;\r\n        request.onload = function () {\r\n            if (request.readyState === 4) {\r\n                if (request.status === 200) {\r\n                    resolve(request);\r\n                }\r\n            }\r\n        };\r\n        request.onerror = function (event) {\r\n            reject(event);\r\n        };\r\n        request.send();\r\n    });\r\n    const request = await p;\r\n    const imageOptions = {\r\n        format: Communicator.ImageFormat.Jpeg,\r\n        data: new Uint8Array(request.response),\r\n    };\r\n    return viewer.model.createImage(imageOptions);\r\n}\r\n\r\npublic static setNodeTexture(viewer : Communicator.WebViewer, nodeId : Communicator.NodeId, imageId : Communicator.ImageId) {\r\n  if (nodeId !== null) {\r\n      const textureOptions = {\r\n          imageId: imageId,\r\n          modifiers: Communicator.TextureModifier.Decal\r\n      };\r\n      viewer.model.setNodesTexture([nodeId], textureOptions);\r\n  }\r\n}\r\n\r\n  public static async createMazeMesh(\r\n    maze: Maze,\r\n    viewer: Communicator.WebViewer,\r\n    rootNodeId: Communicator.NodeId\r\n  ) {\r\n\r\n    const rockColorImageId : Communicator.ImageId = await MazeRenderer.loadImage(viewer, \"data/textures/rock_color.jpg\");\r\n    const brickColorImageId : Communicator.ImageId = await MazeRenderer.loadImage(viewer, \"data/textures/brick_color.jpg\");\r\n\r\n    let meshesRootNodeId = viewer.model.createNode(rootNodeId, \"MeshesRoot\");\r\n\r\n    const cellSize: number = 2;\r\n\r\n    // Filepaths of scs files\r\n    const floorTileFilepath: string = \"data/models/floor.scs\";\r\n    const wallStraightTileFilepath: string = \"data/models/wall_straight.scs\";\r\n\r\n    // Load scs models\r\n    viewer.model.setEnableAutomaticUnitScaling(false);\r\n    let floorTilesNodesIds: Communicator.NodeId[] = await viewer.model.loadSubtreeFromScsFile(meshesRootNodeId, floorTileFilepath);\r\n    let wallStraightNodesIds: Communicator.NodeId[] = await viewer.model.loadSubtreeFromScsFile(meshesRootNodeId, wallStraightTileFilepath);\r\n       \r\n    // Results should contain only one NodeId\r\n    if (floorTilesNodesIds.length != 1) throw \"Invalid floor tile model\";\r\n    if (wallStraightNodesIds.length != 1) throw \"Invalid wall straight model\";\r\n\r\n    let floorTileModelNodeId = floorTilesNodesIds[0];\r\n    let wallStraightModelNodeId = wallStraightNodesIds[0];\r\n\r\n    // Create a root for all model instances\r\n    let floorTileRootNodeId = viewer.model.createNode(rootNodeId,\"FloorTiles\");\r\n\r\n    // Get mesh ids \r\n    let floorTileMeshIds = await viewer.model.getMeshIds([floorTileModelNodeId]);\r\n    let wallStraightMeshIds = await viewer.model.getMeshIds([wallStraightModelNodeId]);\r\n            \r\n    // We still expect only one meshId\r\n    if(floorTileMeshIds.length != 1) throw \"Invalid floor tile model\";\r\n    if(wallStraightMeshIds.length != 1) throw \"Invalid wall straight model\";\r\n\r\n    // UNOPTIMIZED : For each cell instanciate a floor tile.\r\n    for (let rowIndex: number = 0; rowIndex < maze.getRowCount(); ++rowIndex) {\r\n      for (let colIndex: number = 0; colIndex < maze.getColCount(); ++colIndex) {\r\n\r\n        // compute the model matrix to move the tile at good position;\r\n        let netMatrix = viewer.model.getNodeNetMatrix(floorTileRootNodeId);\r\n        netMatrix.m[12] = cellSize * colIndex;\r\n        netMatrix.m[13] = 0;\r\n        netMatrix.m[14] = cellSize * rowIndex;\r\n\r\n        // Create the MeshInstanceData of floor tile\r\n        let meshInstanceData : Communicator.MeshInstanceData = new Communicator.MeshInstanceData(floorTileMeshIds[0], netMatrix, \"Floor Tile Instance\", null, null, null, Communicator.MeshInstanceCreationFlags.DoNotUseVertexColors);\r\n        viewer.model.createMeshInstance(meshInstanceData).then(nodeId => {\r\n        MazeRenderer.setNodeTexture(viewer, nodeId, rockColorImageId); \r\n      });\r\n      }\r\n    }\r\n        \r\n    // Each cell check for up and left wall.\r\n    // Last row and last column check for respectively for botton and right walls.\r\n\r\n    for(let rowIndex : number = 0; rowIndex < maze.getRowCount(); ++rowIndex){\r\n      for(let colIndex : number = 0; colIndex < maze.getColCount(); ++colIndex){\r\n        let node : MazeNode | null = maze.getNodeAtCoord(colIndex, rowIndex); \r\n          if(node != null){\r\n            let leftSlot : MazeNodeRelationSlot = node.getLeftRelation();\r\n            if(!leftSlot.isPathFree()){\r\n                let modelMatrix : Communicator.Matrix = Communicator.Matrix.yAxisRotation(90);\r\n                modelMatrix = modelMatrix.setTranslationComponent(cellSize*colIndex - cellSize*0.5, 0, cellSize*rowIndex);\r\n            \r\n                let meshInstanceData : Communicator.MeshInstanceData = new Communicator.MeshInstanceData(wallStraightMeshIds[0], modelMatrix, \"Straight Wall Instance\", null, null, null, Communicator.MeshInstanceCreationFlags.DoNotUseVertexColors);\r\n                viewer.model.createMeshInstance(meshInstanceData).then(nodeId => {\r\n                MazeRenderer.setNodeTexture(viewer, nodeId, brickColorImageId);\r\n                });\r\n            }\r\n                    \r\n            let upSlot : MazeNodeRelationSlot = node.getUpRelation();\r\n            if(!upSlot.isPathFree()){\r\n                let modelMatrix : Communicator.Matrix = Communicator.Matrix.yAxisRotation(0);\r\n                modelMatrix = modelMatrix.setTranslationComponent(cellSize*colIndex, 0, cellSize*rowIndex - cellSize * 0.5);\r\n            \r\n                let meshInstanceData : Communicator.MeshInstanceData = new Communicator.MeshInstanceData(wallStraightMeshIds[0], modelMatrix, \"Straight Wall Instance\", null, null, null, Communicator.MeshInstanceCreationFlags.DoNotUseVertexColors);\r\n                viewer.model.createMeshInstance(meshInstanceData).then(nodeId => {\r\n                  MazeRenderer.setNodeTexture(viewer, nodeId, brickColorImageId);\r\n                });\r\n            }    \r\n      \r\n            if(rowIndex == maze.getRowCount() - 1){\r\n                let downSlot : MazeNodeRelationSlot = node.getDownRelation();\r\n                if(!downSlot.isPathFree()){\r\n                    let modelMatrix : Communicator.Matrix = Communicator.Matrix.yAxisRotation(0);\r\n                    modelMatrix = modelMatrix.setTranslationComponent(cellSize*colIndex, 0, cellSize*rowIndex + cellSize * 0.5);\r\n                \r\n                    let meshInstanceData : Communicator.MeshInstanceData = new Communicator.MeshInstanceData(wallStraightMeshIds[0], modelMatrix, \"Straight Wall Instance\", null, null, null, Communicator.MeshInstanceCreationFlags.DoNotUseVertexColors);\r\n                    viewer.model.createMeshInstance(meshInstanceData).then(nodeId => {\r\n                      MazeRenderer.setNodeTexture(viewer, nodeId, brickColorImageId);\r\n                    });\r\n                }   \r\n            }\r\n\r\n            if(colIndex == maze.getColCount() - 1){\r\n                let rightSlot : MazeNodeRelationSlot = node.getRightRelation();\r\n                if(!rightSlot.isPathFree()){\r\n                    let modelMatrix : Communicator.Matrix = Communicator.Matrix.yAxisRotation(90);\r\n                    modelMatrix = modelMatrix.setTranslationComponent(cellSize*colIndex + cellSize * 0.5, 0, cellSize*rowIndex);\r\n                \r\n                    let meshInstanceData : Communicator.MeshInstanceData = new Communicator.MeshInstanceData(wallStraightMeshIds[0], modelMatrix, \"Straight Wall Instance\", null, null, null, Communicator.MeshInstanceCreationFlags.DoNotUseVertexColors);\r\n                    viewer.model.createMeshInstance(meshInstanceData).then(nodeId => {\r\n                      MazeRenderer.setNodeTexture(viewer, nodeId, brickColorImageId);\r\n                    });\r\n                }   \r\n            }\r\n        }            \r\n      }\r\n    }\r\n  }\r\n}\r\n"]}